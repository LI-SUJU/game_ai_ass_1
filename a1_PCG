import logging
from random import randint
import random

from termcolor import colored

from gdpc import Block, Editor
from gdpc import geometry as geo
from gdpc import minecraft_tools as mt
from gdpc import editor_tools as et


# Here, we set up Python's logging system.
# GDPC sometimes logs some errors that it cannot otherwise handle.
logging.basicConfig(format=colored("%(name)s - %(levelname)s - %(message)s", color="yellow"))


# === STRUCTURE #2
# These variables are global and can be read from anywhere in the code.
# NOTE: If you want to change a global value inside one of your functions,
#       you'll have to add a line of code. For an example, search 'GLOBAL'.

# Here we construct an Editor object
ED = Editor(buffering=True)

# Here we read start and end coordinates of our build area
BUILD_AREA = ED.getBuildArea()  # BUILDAREA
STARTX, STARTY, STARTZ = BUILD_AREA.begin
LASTX, LASTY, LASTZ = BUILD_AREA.last

# WORLDSLICE
# Using the start and end coordinates we are generating a world slice
# It contains all manner of information, including heightmaps and biomes
# For further information on what information it contains, see
# https://minecraft.fandom.com/wiki/Chunk_format
#
# IMPORTANT: Keep in mind that a wold slice is a 'snapshot' of the world,
# and any changes you make later on will not be reflected in the world slice
WORLDSLICE = ED.loadWorldSlice(BUILD_AREA.toRect(), cache=True)  # this takes a while

ROADHEIGHT = 0

print("Calculating road height...")

heights = WORLDSLICE.heightmaps["MOTION_BLOCKING_NO_LEAVES"]
# Caclulating the average height along where we want to build our road
xaxis = STARTX + (LASTX - STARTX) // 2  # Getting start + half the length
zaxis = STARTZ + (LASTZ - STARTZ) // 2
y = heights[(xaxis - STARTX, zaxis - STARTZ)]
for x in range(STARTX, LASTX + 1):
    newy = heights[(x - STARTX, zaxis - STARTZ)]
    y = (y + newy) // 2
for z in range(STARTZ, LASTZ + 1):
    newy = heights[(xaxis - STARTX, z - STARTZ)]
    y = (y + newy) // 2

    # GLOBAL
    # By calling 'global ROADHEIGHT' we allow writing to ROADHEIGHT.
    # If 'global' is not called, a new, local variable is created.
ROADHEIGHT = y
print(f"Road height is {ROADHEIGHT}")
# === STRUCTURE #3
# Here we are defining all of our functions to keep our code organised
# They are:
# - buildPerimeter()
# - buildRoads()
# - buildCity()


def buildPerimeter():
    """Build a wall along the build area border.

    In this function we're building a simple wall around the build area
        pillar-by-pillar, which means we can adjust to the terrain height
    """
    # HEIGHTMAP
    # Heightmaps are an easy way to get the uppermost block at any coordinate
    # There are four types available in a world slice:
    # - 'WORLD_SURFACE': The top non-air blocks
    # - 'MOTION_BLOCKING': The top blocks with a hitbox or fluid
    # - 'MOTION_BLOCKING_NO_LEAVES': Like MOTION_BLOCKING but ignoring leaves
    # - 'OCEAN_FLOOR': The top solid blocks
    heights = WORLDSLICE.heightmaps["MOTION_BLOCKING_NO_LEAVES"]

    print("Building east-west walls...")

    for x in range(STARTX, LASTX + 1):
        # The northern wall
        y = heights[(x - STARTX, 0)]
        geo.placeCuboid(ED, (x, y - 2, STARTZ), (x, y, STARTZ), Block("granite"))
        geo.placeCuboid(ED, (x, y + 1, STARTZ), (x, y + 4, STARTZ), Block("granite_wall"))
        # The southern wall
        y = heights[(x - STARTX, LASTZ - STARTZ)]
        geo.placeCuboid(ED, (x, y - 2, LASTZ), (x, y, LASTZ), Block("red_sandstone"))
        geo.placeCuboid(ED, (x, y + 1, LASTZ), (x, y + 4, LASTZ), Block("red_sandstone_wall"))

    print("Building north-south walls...")

    for z in range(STARTZ, LASTZ + 1):
        # The western wall
        y = heights[(0, z - STARTZ)]
        geo.placeCuboid(ED, (STARTX, y - 2, z), (STARTX, y, z), Block("sandstone"))
        geo.placeCuboid(ED, (STARTX, y + 1, z), (STARTX, y + 4, z), Block("sandstone_wall"))
        # The eastern wall
        y = heights[(LASTX - STARTX, z - STARTZ)]
        geo.placeCuboid(ED, (LASTX, y - 2, z), (LASTX, y, z), Block("prismarine"))
        geo.placeCuboid(ED, (LASTX, y + 1, z), (LASTX, y + 4, z), Block("prismarine_wall"))


def buildRoads():
    """Build a road from north to south and east to west."""
    xaxis = STARTX + (LASTX - STARTX) // 2  # Getting start + half the length
    zaxis = STARTZ + (LASTZ - STARTZ) // 2
    heights = WORLDSLICE.heightmaps["MOTION_BLOCKING_NO_LEAVES"]

    print("Calculating road height...")
    # Caclulating the average height along where we want to build our road
    y = heights[(xaxis - STARTX, zaxis - STARTZ)]
    for x in range(STARTX, LASTX + 1):
        newy = heights[(x - STARTX, zaxis - STARTZ)]
        y = (y + newy) // 2
    for z in range(STARTZ, LASTZ + 1):
        newy = heights[(xaxis - STARTX, z - STARTZ)]
        y = (y + newy) // 2

    # GLOBAL
    # By calling 'global ROADHEIGHT' we allow writing to ROADHEIGHT.
    # If 'global' is not called, a new, local variable is created.
    global ROADHEIGHT
    ROADHEIGHT = y

    print("Building east-west road...")

    geo.placeCuboid(ED, (xaxis - 2, y, STARTZ), (xaxis - 2, y, LASTZ), Block("end_stone_bricks"))
    geo.placeCuboid(ED, (xaxis - 1, y, STARTZ), (xaxis + 1, y, LASTZ), Block("gold_block"))
    geo.placeCuboid(ED, (xaxis + 2, y, STARTZ), (xaxis + 2, y, LASTZ), Block("end_stone_bricks"))
    geo.placeCuboid(ED, (xaxis - 1, y + 1, STARTZ), (xaxis + 1, y + 3, LASTZ), Block("air"))

    print("Building north-south road...")

    geo.placeCuboid(ED, (STARTX, y, zaxis - 2), (LASTX, y, zaxis - 2), Block("end_stone_bricks"))
    geo.placeCuboid(ED, (STARTX, y, zaxis - 1), (LASTX, y, zaxis + 1), Block("gold_block"))
    geo.placeCuboid(ED, (STARTX, y, zaxis + 2), (LASTX, y, zaxis + 2), Block("end_stone_bricks"))
    geo.placeCuboid(ED, (STARTX, y + 1, zaxis - 1), (LASTX, y + 3, zaxis + 1), Block("air"))

def buildPlatform():
    print("Building platform...")
    #get the highest point in an area
    heights = WORLDSLICE.heightmaps["MOTION_BLOCKING_NO_LEAVES"]
    highestHeight = 0
    platformSTARTX=randint(STARTX, LASTX-50)
    platformSTARTZ=randint(STARTZ, LASTZ-50)
    print(f"Platform start: {platformSTARTX}, {platformSTARTZ}")
    for x in range(platformSTARTX, platformSTARTX+50):
        for z in range(platformSTARTZ, platformSTARTZ+50):
            y = heights[(x - platformSTARTX, z - platformSTARTZ)]
            if y > highestHeight:
                highestHeight = y
    print(f"Highest point: {highestHeight}")
    corner1 = (platformSTARTX, heights[(platformSTARTX,platformSTARTZ)], platformSTARTZ)
    base1 = (platformSTARTX, highestHeight+1, platformSTARTZ)
    corner2 = (platformSTARTX+50, heights[(platformSTARTX+50,platformSTARTZ+50)], platformSTARTZ+50)
    base2 = (platformSTARTX+50, highestHeight+1, platformSTARTZ+50)
    corner3 = (platformSTARTX+50, heights[(platformSTARTX+50,platformSTARTZ)], platformSTARTZ)
    base3 = (platformSTARTX+50, highestHeight+1, platformSTARTZ)
    corner4 = (platformSTARTX, heights[(platformSTARTX,platformSTARTZ+50)], platformSTARTZ+50)
    base4 = (platformSTARTX, highestHeight+1, platformSTARTZ+50)
    geo.placeCuboid(ED, corner1, base1, Block("stone"))
    geo.placeCuboid(ED, corner2, base2, Block("stone"))
    geo.placeCuboid(ED, corner3, base3, Block("stone"))
    geo.placeCuboid(ED, corner4, base4, Block("stone"))
    geo.placeCuboid(ED, base1, base2, Block("stone"))
    geo.placeCuboid(ED, base2, base1, Block("stone"))
    print("Building house...")
    buildHouse(platformSTARTX, platformSTARTZ, highestHeight)

def buildHouse(x,z, highestHeight):
    houseSTARTX=x+10
    houseSTARTZ=z+10
    houseENDX=x+40
    houseENDZ=z+40
    # house properties
    class house:
        nfloors = randint(1, 5)
    print(f"Building house with {house.nfloors} floors...")
    # floor properties

    # build outer walls
    geo.placeCuboid(ED, (houseSTARTX, highestHeight, houseSTARTZ), (houseENDX, highestHeight+15, houseSTARTZ), Block("stone"))
    geo.placeCuboid(ED, (houseSTARTX, highestHeight, houseENDZ), (houseENDX, highestHeight+15, houseENDZ), Block("stone"))
    geo.placeCuboid(ED, (houseSTARTX, highestHeight, houseSTARTZ), (houseSTARTX, highestHeight+15, houseENDZ), Block("stone"))
    geo.placeCuboid(ED, (houseENDX, highestHeight, houseSTARTZ), (houseENDX, highestHeight+15, houseENDZ), Block("stone"))
    # build door
    geo.placeCuboid(ED, (houseSTARTX+1, highestHeight, houseSTARTZ), (houseSTARTX+5, highestHeight+5, houseSTARTZ), Block("air"))
    #build roof
    geo.placeCuboid(ED, (houseSTARTX, highestHeight+15, houseSTARTZ), (houseENDX, highestHeight+15, houseENDZ), Block("stone"))
    for i in range(house.nfloors):
        class floor: 
            nthFloor= i+1,
            floorHeight= 15,
            windowWidth=randint(2, 5),
            windowHeight= randint(2, 5),
            windowStart= (random.choice([houseSTARTX, houseENDX]), randint(1,10),random.choice([houseSTARTZ, houseENDZ])),
            stairsEntranceStart= (0,0,0),
        x=highestHeight+floor.floorHeight*floor.nthFloor
        floor.stairsEntranceStart= (random.choice([houseSTARTX+1]), x,random.choice([houseSTARTZ+1])),
        
        #build windows
        geo.placeCuboid(ED, floor.windowStart, (floor.windowStart[0]+floor.windowWidth, highestHeight+floor.floorHeight*(floor.nthFloor-1)+floor.windowHeight, floor.windowStart[2]), Block("glass"))
        #build stairs
        geo.placeCuboid(ED, floor.stairsEntranceStart, (floor.stairsEntranceStart[0]+2, floor.stairsEntranceStart[1], floor.stairsEntranceStart[2]+2), Block("air"))

def main():
    try:
        # buildPerimeter()
        # buildRoads()
        buildPlatform()
        print("Done!")

    except KeyboardInterrupt: # useful for aborting a run-away program
        print("Pressed Ctrl-C to kill program.")


# === STRUCTURE #4
# The code in here will only run if we run the file directly (not imported).
# This prevents people from accidentally running your generator.
# It is recommended to directly call a function here, because any variables
# you declare outside a function will be global.
if __name__ == '__main__':
    main()